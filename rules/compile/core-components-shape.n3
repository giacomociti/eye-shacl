
# https://www.w3.org/TR/shacl/#core-components-shape

@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix sh: <http://www.w3.org/ns/shacl#>.
@prefix this: <http://eye-shacl#> .

# NodeConstraintComponent
# {
#     ?shape sh:node ?nodeShape ; sh:path ?path .
#     [] log:notIncludes { ?shape sh:deactivated true } .
#     ?nodeShape log:localN3String ?nodeShapeString .
#     ("value should have shape: %s" ?nodeShapeString) string:format ?message .
# }
# =>
# {
#     {
#         this: this:report ?report .

#         ?shape this:focusNode ?node .
#         (?node ?path) this:value ?value .

#         ?value this:violates ?nodeShape .

#     }
#     =>
#     {
#         ?report sh:result [
#             a sh:ValidationResult ;
#             sh:sourceConstraintComponent sh:NodeConstraintComponent;
#             sh:sourceShape ?shape ;
#             sh:focusNode ?node ;
#             sh:value ?value ;
#             sh:resultPath ?path ;
#             this:message ?message ;
#         ] .
#     } .
# } .

# {
#     ?shape sh:node ?nodeShape ; sh:path ?path .
#     [] log:notIncludes { ?shape sh:deactivated true } .
# }
# =>
# {
#     {
#         ?node this:violates ?shape .
#     }
#     <=
#     {
#         (?node ?path) this:value ?value .
#         ?value this:violates ?nodeShape .
#     } .
# } .


# {
#     ?shape sh:node ?nodeShape ; a sh:NodeShape .
#     [] log:notIncludes { ?shape sh:deactivated true } .
#     ?nodeShape log:localN3String ?nodeShapeString .
#     ("value should have shape: %s" ?nodeShapeString) string:format ?message .
# }
# =>
# {
#     {
#         this: this:report ?report .
#         ?shape this:focusNode ?node .
#         ?node this:violates ?nodeShape .
#     }
#     =>
#     {
#         ?report sh:result [
#             a sh:ValidationResult ;
#             sh:sourceConstraintComponent sh:NodeConstraintComponent;
#             sh:sourceShape ?shape ;
#             sh:focusNode ?node ;
#             sh:value ?node ;
#             this:message ?message ;
#         ] .
#     } .
# } .

# {
#     ?shape sh:node ?nodeShape ; a sh:NodeShape .
#     [] log:notIncludes { ?shape sh:deactivated true } .
# }
# =>
# {
#     {
#         ?node this:violates ?shape .
#     }
#     <=
#     {
#         ?node this:violates ?nodeShape .
#     } .
# } .

# PropertyShapeComponent

# node -> property
{
    ?shape sh:property ?propertyShape ; a sh:NodeShape .
    [] log:notIncludes { ?shape sh:deactivated true } .
}
=> 
{
    { ?propertyShape this:focusNode ?node } <= { ?shape this:focusNode ?node }
} .

{
    ?shape sh:property ?propertyShape ; a sh:NodeShape .
    [] log:notIncludes { ?shape sh:deactivated true } .
}
=> 
{
    { ?node this:violates ?shape } <= { ?node this:violates ?propertyShape }
} .

# property -> property
{
    ?shape sh:property ?propertyShape ; sh:path ?path .
    [] log:notIncludes { ?shape sh:deactivated true } .
}
=> 
{
    {
        ?propertyShape this:focusNode ?value 
    }
    <= 
    {
        ?shape this:focusNode ?node .
        (?node ?path) this:value ?value 
    }
} .

{
    ?shape sh:property ?propertyShape ; sh:path ?path .
    [] log:notIncludes { ?shape sh:deactivated true } .
}
=> 
{
    { 
        ?node this:violates ?shape 
    } 
    <=
    { 
        (?node ?path) this:value ?value .
        ?value this:violates ?propertyShape 
    }
} .

# qualifiedValueShape
 

{
    ?shape sh:qualifiedMinCount ?minCount .
    ?shape sh:qualifiedValueShape ?valueShape ; sh:path ?path .
}
=>
{
    {
        ?shape this:focusNode ?node .
        ?node this:qualifiedCount (?shape ?length) .
        ?length math:lessThan ?minCount .

        ("%s values passed, expected at least %s" ?length ?minCount) string:format ?message .
        this: this:report ?report .
    }
    =>
    {
        ?report sh:result [
            a sh:ValidationResult ;
            sh:sourceConstraintComponent sh:QualifiedMinCountConstraintComponent;
            sh:sourceShape ?shape ;
            sh:focusNode ?node ;
            sh:resultPath ?path ;
            this:message ?message ;
        ] .
    } .
} .

{
    ?shape sh:qualifiedMaxCount ?maxCount .
    ?shape sh:qualifiedValueShape ?valueShape ; sh:path ?path .
}
=>
{
    {
        ?shape this:focusNode ?node .
        ?node this:qualifiedCount (?shape ?length) .
        ?length math:greaterThan ?maxCount .

        ("%s values passed, expected at most %s" ?length ?maxCount) string:format ?message .
        this: this:report ?report .
    }
    =>
    {
        ?report sh:result [
            a sh:ValidationResult ;
            sh:sourceConstraintComponent sh:QualifiedMaxCountConstraintComponent;
            sh:sourceShape ?shape ;
            sh:focusNode ?node ;
            sh:resultPath ?path ;
            this:message ?message ;
        ] .
    } .
} .


{
    ?shape sh:qualifiedValueShape ?valueShape ; sh:path ?path .
    [] log:notIncludes { ?shape sh:deactivated true } .
    (
        ?x {
            ?shape sh:qualifiedValueShapesDisjoint true .
            ?parent sh:property ?shape, ?other .
            ?shape log:notEqualTo ?other .
            ?other sh:qualifiedValueShape ?x
        } ?siblings
    ) log:collectAllIn [] .
}
=>
{
    {
       ?node this:qualifiedCount (?shape ?length)
    }
    <=
    {
        (?node ?path) this:values ?values .
        (?x { 
            ?x list:in ?values . 
            [] log:notIncludes { ?x this:violates ?valueShape } .
            (
                { ?sibling list:in ?siblings }
                { ?x this:violates ?sibling }
            ) log:forAllIn [] .
        } ?xs) log:collectAllIn [] .
                
        ?xs list:length ?length .
    } .
} .


{
    ?shape sh:qualifiedMinCount ?minCount .
    ?shape sh:qualifiedValueShape ?valueShape ; sh:path ?path .
}
=>
{
    {
       ?node this:violates ?shape
    }
    <=
    {
        ?node this:qualifiedCount (?shape ?length) .
        ?length math:lessThan ?minCount .
    } .
} .

{
    ?shape sh:qualifiedMaxCount ?maxCount .
    ?shape sh:qualifiedValueShape ?valueShape ; sh:path ?path .
}
=>
{
    {
       ?node this:violates ?shape
    }
    <=
    {
        ?node this:qualifiedCount (?shape ?length) .
        ?length math:greaterThan ?maxCount .
    } .
} .